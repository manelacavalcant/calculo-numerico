import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import math as math

# x^(3/4)-cos(x^2) = 0

def Modulo(x):
  if x > 0:
    return x
  else:
    return -x

def Sinal_igual(x1,x2):
  if (x1 > 0 and x2 > 0) or (x1 < 0 and x2 < 0):
    return True
  else:
    return False

def f(x):  # função
  return x**(3/4)-np.cos(x**2)
def F(x):  # derivada
  # Para prevenir o erro caso a derivada seja zero
  if x == 0:
    return 0 
  return (3/4)*(x**(-1/4))+2*x*np.sin(x**2)

# Para plotar o gráfico:
def fg(x):
  graf = []
  for i in range(len(x)):
    gi = x[i]**(3/4)-np.cos(x[i]**2)
    graf.append(gi)
  return graf
x = np.arange(0,9,0.01)
y = fg(x)
plt.figure(figsize=(10, 6))
plt.plot(x,y, color = 'purple')
# plt.scatter(Bisseccao(),f(Bisseccao()), color = 'red',label='Método da Bissecção')
plt.grid(True, linestyle='--')
plt.xlabel('x')
plt.ylabel('f(x)=x^(3/4)-cos(x^2)')
# plt.legend()
plt.show()

# Método da bissecção:
def Bisseccao():
  x1,x2,x0 = 0,1,0
  epsilon = 2**(-10)
  while Modulo(x2-x1) > epsilon:
    x0 = (x1+x2)/2
    if Sinal_igual(f(x1),f(x0)):
      x1 = x0
    else:
      x2 = x0
    print('x1 = ',x1,'\n','x2 = ',x2,'\n', 'x_m = ',x0)
  return x0

# Método de Newton-Raphson:
def NewtonRaphson():
  x0,x1,aux = 1,0.5,0
  n = 0
  epsilon = 2**(-10)
  while Modulo((x1 - x0)/x0) > epsilon:  # Erro relativo
    aux = x1 # variável auxiliar
    x1 = x0-(f(x0)/F(x0))
    x0 = aux
    print('n = ',n,'x0 = ',x0,'\n', 'x1 = ',x1,'\n', 'f(x0) = ',f(x0),'\n', "f'(x0) = ",F(x0))
    n += 1
  return x0

Bisseccao()
NewtonRaphson()
